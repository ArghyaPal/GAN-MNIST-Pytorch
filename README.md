# GAN-MNIST-Pytorch

In this blog post we'll implement a generative image model that converts random noise into images of digits! **The full code is available [here](https://github.com/BeierZhu/GAN-MNIST-Pytorch), just clone it to your machine and it's ready to play.** As a former Torch7 user, I attempt to reproduce the results from the [Torch7 post](http://torch.ch/blog/2015/11/13/gan.html).

For this, we employ [Generative Adversarial Network](https://arxiv.org/abs/1406.2661). A GAN consists of two components; a generator which converts random noise into images and a discriminator which tries to distinguish between generated and real images. Here, ‘real’ means that the image came from our training set of images in contrast to the generated fakes.

To train the model we let the discriminator and generator play a game against each other. We first show the discriminator a mixed batch of real images from our training set and of fake images generated by the generator. We then simultaneously optimize the discriminator to answer NO to fake images and YES to real images and optimize the generator to fool the discriminator into believing that the fake images were real. This corresponds to minimizing the classification error wrt. the discriminator and maximizing it wrt. the generator. With careful optimization both generator and discriminator will improve and the generator will eventually start generating convincing images.

# Implementing a GAN
We implement the generator and discriminator as convnets and train them with stochastic gradient descent.

The discriminator is a mlp with consecutive blocks of Linear Layer and LeakyReLU activation.

``` python
D = nn.Sequential(
    nn.Linear(image_size, hidden_size),
    nn.LeakyReLU(0.2),
    nn.Linear(hidden_size, hidden_size),
    nn.LeakyReLU(0.2),
    nn.Linear(hidden_size, 1),
    nn.Sigmoid())
```

This is a pretty standard architecture. The 28x28 grey images of digits are converted into a 781x1 vector by stacking their columns. The discriminator takes a 784x1 vector as input and predicts YES or NO with a single sigmoid output.

The generator is a mlp with a vector with Linear Layer and ReLU activation repeatedly:

```python
G = nn.Sequential(
    nn.Linear(latent_size, hidden_size),
    nn.ReLU(),
    nn.Linear(hidden_size, hidden_size),
    nn.ReLU(),
    nn.Linear(hidden_size, image_size),
    nn.Tanh())
```
To generate an image we feed the generator with noise distributed N(0,1). After successful training, the output should be meaningful images!

```python
z = torch.randn(batch_size, latent_size).cuda()
z = Variable(z)
fake_images = G(z)
```
# Generating digits
We train our GAN using images of digits from the [MNIST](http://yann.lecun.com/exdb/mnist/) dataset. After at around 5 epochs you should start to see blurr digits. And after 80 epochs the results look pleasant.
![after 5 epochs](https://upload-images.jianshu.io/upload_images/1231993-7f351e4231847f02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![after 100 epochs](https://upload-images.jianshu.io/upload_images/1231993-4eff1a4d2b405a42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
# Loss and Discriminator Accuracy
![accuracy.png](https://upload-images.jianshu.io/upload_images/1231993-d76f92bd4f431100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![loss.png](https://upload-images.jianshu.io/upload_images/1231993-e9e0a1f787427637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


We also record the accuracy of the discriminator and the loss of the discriminator and the generator after each epoch.  Refer to [GAN](https://arxiv.org/abs/1406.2661), when the global minimum of the training criterion is achieved, the loss should be -log4 and the accuracy should be 0.5. Our model does not achieve the ideal result. Moreover, as we can see from the figure, our model start to overfit at around 80 epochs. The model structure and the training strategy should be improved in the future.


